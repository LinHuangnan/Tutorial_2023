### 任务一：还原视频背景图 ###

1. 还原视频背景图（python）：

> 一开始由于不太了解背景还原的原理，所以上网搜索了资料后发现网上所用的方法大部分都是使用OpenCV的自带库函数``` cv::BackgroundSubtractor```来解决的，我根据网上的教程使用了MOG2算法，也明白了具体的原理之后。自己使用了``` cv2.absdiff```函数帧差法来实现对应的还原视频背景的要求，并且也明白了帧差法与这种算法之间的差距
>
> 接下来是针对OpenCV给出的样例视频做出对比：
>
> [MOG2官方程序实现人物识别](./image/MOG2.png)
>
> [MOG2自己编写代码](./image/MOG2(simple).jpg)
>
> [使用帧差法得出结果](./image/absdiff.png)
>
> 可以看出上面三者的主要区别在于生成的掩码，帧差法生成的掩码图跟其他使用库函数的识别程度还是有一定的距离的。

2. 还原视频背景图（C++）：

   >* 因为之前一直使用的是python（调用库函数较为方便，代码更为简洁，编译更加容易），所以本次将上述编写好的python根据要求分别在``` Recovery.h```,``` Recovery.cpp```和``` demo.cpp``` 实现。本次遇到的问题就是编写C++代码时，要么是编译器的版本有要求，要么是找不到cv2的库函数。后面在上网查找资料的时候也是最终成功解决了相应问题。
   >
   >  * 首先就是对应的版本要如何修改：
   >
   >    >使用cmake编译时，编写CMakeLists.txt文件，在此文件中添加``` set(CMAKE_CXX_STANDARD 11)```这样就可以指定编译版本。
   >    >
   >    >而对于找不到``` opencv```的动态库的问题，需要在文件中添加相应的动态库
   >    >
   >    >```cmake
   >    >target_link_libraries( demo ${OpenCV_LIBS} ) //生成可执行文件demo与Opencv库链接起来
   >    >include_directories( ${OpenCV_INCLUDE_DIRS} ) //将Opencv库的头文件包含进来
   >    >find_package( OpenCV REQUIRED ) //查找Opencv库
   >    >```
   >
   >* 使用cmake编译后得到了下列结果：
   >
   >  [video1](./image/video1.jpg)
   >
   >  [video2](./image/video2.jpg)
   >
   >  [video3](./image/video3.jpg)
   >
   >  最终也是成功把三个视频背景还原出来。
   >
   >* 根据要求使用了``` std:chrono```函数来度量自己算法所使用的时间，接下来是结果展示：
   >
   >  [时间度量](./image/result.png)
   >
   >  执行程序时，首先会展示恢复后的原视频和对应产生的掩码视频，而这段时间也是有被计算到的，之后视频展示完毕之后，就会自己展示对应的截图。（这部分时间并没有被计入）
   >
   >  * 使用该函数时也存在问题，因为该函数要求编译器的版本在c++14以上，所以需要修改CMakeLists.txt文件中的指定编译版本。
   >
   >    ``` set(CMAKE_CXX_STANDARD 14)```刚好同时也能兼容Opencv的库函数。



### 任务二：利用摄像头作为输入流 ###

1. 实现利用摄像头输入流得到结果

   >通过添加对应的``` void videoCannel(int n)```函数，从自带摄像头读取相应结果。



#### 更多代码细节将在另一份文档中描述 ####

该算法需要自己更改需要实现的视频文件，相应的视频放在video文件夹中。

相应的所有文件都打包在task.zip中。





​	





 

 





















 

  

